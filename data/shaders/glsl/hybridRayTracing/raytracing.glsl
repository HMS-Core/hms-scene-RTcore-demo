// following codes are generated by rayshop.

// #define RAY_FLAG_ANY_HIT                        0x1
// #define RAY_FLAG_CLOSEST_HIT                    0x2
// #define RAY_FLAG_CULL_BACK_FACING_TRIANGLES     0x4
// #define RAY_FLAG_CULL_FRONT_FACING_TRIANGLES    0x8

// const float INFINITE = 1e38f;

// struct Ray {
//     vec3 origin;
//     float mint;
//     vec3 direction;
//     float maxt;
// };

// TraceRayHitFormat -- T_PRIMID_INSTID_U_V
// struct HitInfo {
//     float t;
//     uint triId;
//     uint instId;
//     float u;
//     float v;
// };

// TraceRayHitFormat -- T_PRIMID_INSTID
// struct HitInfo {
//     float t;
//     uint triId;
//     uint instId;
// };

// TraceRayHitFormat -- T_PRIMID_U_V
// struct HitInfo {
//     float t;
//     uint triId;
//     float u;
//     float v;
// };

// TraceRayHitFormat -- T_PRIMID
// struct HitInfo {
//     float t;
//     uint triId;
// };

// TraceRayHitFormat -- T
// struct HitInfo {
//     float t;
// };

// void traceRay(in Ray ray, in uint rayFlags, inout HitInfo hit);

// layout (std430, set = 0, binding = 0) buffer cpr4xBvh
// {
//     uvec4 bvhNode[];
// };

// layout (std430, set = 0, binding = 1) buffer triangleInBuffer
// {
//     uvec4 triangleBuffer[];
// };

// struct BLASINFO {
//     uint blasIdx;
//     uint offset;
//     uint index;
//     uint pad;
//     mat4 tansMat;
// };
// layout (std430, set = 0, binding = 2) buffer blasInfoBuffer {
//     BLASINFO blasInfos[];
// };

// layout (set = 0, binding = 3) uniform RTUniform {};

// clang-format off
layout (early_fragment_tests) in;
#define RAY_TRACING
#define FRAGMENT_SHADER
#extension GL_GOOGLE_include_directive : enable
#include "common.glsl"
//#define USE_PBR_REFLECT 1     // enable pbr for reflection

layout(location = 0) in vec4 inWorldPos;
layout(location = 1) in vec3 inNormal;
layout(location = 2) in vec2 inUV;

layout(location = 0) out vec4 outColor;

const float BLEND_FACTOR = 0.6f;

void getHitInformation(
    const ivec3 triangleIndices,
    const vec2 centerUV,
    out vec4 hitColor,
    out vec2 hitSampeUV,
    out vec3 hitPosition,
    out vec3 hitNormal)
{
    vec4 hitColor0 = vertexBuffer[triangleIndices.x].color;
    vec4 hitColor1 = vertexBuffer[triangleIndices.y].color;
    vec4 hitColor2 = vertexBuffer[triangleIndices.z].color;
    hitColor = hitColor0 * (1 - centerUV.x - centerUV.y) + hitColor1 * centerUV.x + hitColor2 * centerUV.y;

#ifdef USE_PBR_REFLECT
    vec2 hitSampleUV0 = vertexBuffer[triangleIndices.x].uv.xy;
    vec2 hitSampleUV1 = vertexBuffer[triangleIndices.y].uv.xy;
    vec2 hitSampleUV2 = vertexBuffer[triangleIndices.z].uv.xy;

    vec3 hitPosition0 = vec3(vertexBuffer[triangleIndices.x].pos.xyz);
    vec3 hitPosition1 = vec3(vertexBuffer[triangleIndices.y].pos.xyz);
    vec3 hitPosition2 = vec3(vertexBuffer[triangleIndices.z].pos.xyz);

    vec3 hitNormal0 = vec3(vertexBuffer[triangleIndices.x].normal.xyz);
    vec3 hitNormal1 = vec3(vertexBuffer[triangleIndices.y].normal.xyz);
    vec3 hitNormal2 = vec3(vertexBuffer[triangleIndices.z].normal.xyz);

    vec4 joint0_0 = vertexBuffer[triangleIndices.x].joint0;
    vec4 joint0_1 = vertexBuffer[triangleIndices.y].joint0;
    vec4 joint0_2 = vertexBuffer[triangleIndices.z].joint0;

    vec4 weight0_0 = vertexBuffer[triangleIndices.x].weight0;
    vec4 weight0_1 = vertexBuffer[triangleIndices.y].weight0;
    vec4 weight0_2 = vertexBuffer[triangleIndices.z].weight0;

    convetLocalToWorld(hitPosition0, hitNormal0, joint0_0, weight0_0);
    convetLocalToWorld(hitPosition1, hitNormal1, joint0_1, weight0_1);
    convetLocalToWorld(hitPosition2, hitNormal2, joint0_2, weight0_2);

    hitSampeUV = hitSampleUV0 * (1 - centerUV.x - centerUV.y) + hitSampleUV1 * centerUV.x + hitSampleUV2 * centerUV.y;
    hitPosition = hitPosition0 * (1 - centerUV.x - centerUV.y) + hitPosition1 * centerUV.x + hitPosition2 * centerUV.y;
    hitNormal = hitNormal0 * (1 - centerUV.x - centerUV.y) + hitNormal1 * centerUV.x + hitNormal2 * centerUV.y;
#endif
}

vec4 simplePBR(in vec4 baseColor, const vec2 drawSampleUV, const vec3 drawPosition, const vec3 drawNormal)
{
    float perceptualRoughness;
    float metallic;
    vec3 diffuseColor;

    vec3 f0 = vec3(0.04);
    if (material.workflow == PBR_WORKFLOW_METALLIC_ROUGHNESS) {
        // Metallic and Roughness material properties are packed together
        // In glTF, these factors can be specified by fixed scalar values
        // or from a metallic-roughness map
        perceptualRoughness = material.roughnessFactor;
        metallic = material.metallicFactor;
        if (material.physicalDescriptorTextureSet > -1) {
            // Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.
            // This layout intentionally reserves the 'r' channel for (optional) occlusion map data
            vec4 mrSample = texture(physicalDescriptorMap, drawSampleUV);
            perceptualRoughness = mrSample.g * perceptualRoughness;
            metallic = mrSample.b * metallic;
        } else {
            perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);
            metallic = clamp(metallic, 0.0, 1.0);
        }
    }

    diffuseColor = baseColor.rgb * (vec3(1.0) - f0);
    diffuseColor *= 1.0 - metallic;

    float alphaRoughness = perceptualRoughness * perceptualRoughness;

    vec3 specularColor = mix(f0, baseColor.rgb, metallic);

    // Compute reflectance.
    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);

    // For typical incident reflectance range (between 4% to 100%) set the grazing reflectance to 100% for typical
    // fresnel effect. For very low reflectance range on highly diffuse objects (below 4%), incrementally reduce grazing
    // reflecance to 0%.
    float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);
    vec3 specularEnvironmentR0 = specularColor.rgb;
    vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;
    vec3 n = normalize(drawNormal);
    vec3 v = normalize(ubo.camPos - drawPosition); // Vector from surface point to camera
    vec3 l = normalize(uboParams.lightDir.xyz);    // Vector from surface point to light
    vec3 h = normalize(l + v);                     // Half vector between both l and v
    vec3 reflection = -normalize(reflect(v, n));
    reflection.y *= -1.0f;

    float NdotL = clamp(dot(n, l), 0.001, 1.0);
    float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);
    float NdotH = clamp(dot(n, h), 0.0, 1.0);
    float LdotH = clamp(dot(l, h), 0.0, 1.0);
    float VdotH = clamp(dot(v, h), 0.0, 1.0);

    PBRInfo pbrInputs = PBRInfo(NdotL, NdotV, NdotH, LdotH, VdotH, perceptualRoughness, metallic, specularEnvironmentR0,
                                specularEnvironmentR90, alphaRoughness, diffuseColor, specularColor);

    // Calculate the shading terms for the microfacet specular shading model
    vec3 F = specularReflection(pbrInputs);
    float G = geometricOcclusion(pbrInputs);
    float D = microfacetDistribution(pbrInputs);

    const vec3 u_LightColor = vec3(1.0);

    // Calculation of analytical lighting contribution
    vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);
    vec3 specContrib = F * G * D / (4.0 * NdotL * NdotV);
    // Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)
    vec3 color = NdotL * u_LightColor * (diffuseContrib + specContrib);

    // Calculate lighting contribution from image based lighting source (IBL)
    color += getIBLContribution(pbrInputs, n, reflection);

    const float u_OcclusionStrength = 1.0f;
    // Apply optional PBR terms for additional (optional) shading
    if (material.occlusionTextureSet > -1) {
        float ao = texture(aoMap, drawSampleUV).r;
        color = mix(color, color * ao, u_OcclusionStrength);
    }

    const float u_EmissiveFactor = 1.0f;
    if (material.emissiveTextureSet > -1) {
        vec3 emissive = SRGBtoLINEAR(texture(emissiveMap, drawSampleUV)).rgb * u_EmissiveFactor;
        color += emissive;
    }

    return vec4(color, baseColor.a);
}
